# Глава 12. Перечисления, автоупаковка и аннотации (метаданные)

## Перечисления

**Перечисление** представляет собой список именованных констант и в Java **является классом**.

* Каждая константа перечисления является объектом класса своего перечисления
  (имеет тип того перечисления, в котором она объявлена);
* Может иметь конструкторы, методы и переменные экземпляра, даже реализацию интерфейсов;
* Нельзя получать экземпляры класса enum с помощью оператора new;
* Автоматически наследуется от класса java.lang.Enum;
* Не может наследоваться от другого класса, не может быть суперклассом.

Перечисления появились в JDK 5.

Перечисление создаётся с помощью ключевого слова **enum**.

Некоторые методы класса перечисления: values, valueOf, ordinal, compareTo, equals.

```
enum имя_класса_перечисления {
    самотипизированные_константы_перечислимого_типа
    возможные конструкторы, методы и переменные экземпляра
}

// например, перечисление сортов яблок
// каждая из констант имеет тип Apple, явно объявлена как открытый статический конечный член класса Apple

enum Apple {
    Jonathan, GoldenDel, RedDel, Winesap, Cortland
}
```

## Оболочки типов (классы-обёртки)

Оболочки типов = классы-обёртки (wrapper).

**Оболочки типов** - это классы, заключающие примитивный тип данных в оболочку объекта.

Они необходимы из-за того, что многие стандартные структуры данных, реализованные в Java, оперируют объектами.
Оболочки типов передаются по ссылке.

Классы оболочек типов (в отличие от примитивных типов данных) входят в иерархию объектов Java.

**Классы оболочек типов** из пакета java.lang:

* Character - оболочка для char;
* Boolean - оболочка для boolean;
* Byte, Short, Integer, Long, Float, Double - оболочки числовых типов (byte, short, int, long, float, double);
  наследуются от абстрактного класса Number;
* Void - содержит единственное поле TYPE, в котором хранится ссылка на объект типа Class для типа void;
  экземпляры этого класса не создаются.

**Упаковка** (boxing) - процесс инкапсуляции значения примитивного типа в объекте - оболочке типа: 
  Integer intObj = new Integer(100);
  
**Распаковка** (unboxing) - процесс извлечения значения из оболочки типа в примитивный тип:
  int i = intObj.intValue();

## Автоупаковка и автораспаковка

Автоупаковка и автораспаковка появились в JDK 5.

**Автоупаковка** (autoboxing) - _автоматический_ процесс инкапсуляции (упаковки) значения примитивного типа
  в оболочке типа (без явного создания объекта оператором new / конструктором класса):
  Integer intObj = 100;

**Автораспаковка** (autounboxing) - это процесс _автоматического_ извлечения значения (распаковки) примитивного типа 
  из оболочки типа (без явного вызова методов типа intValue(), doubleValue()):
  int i = intObj;

Автоупаковка и автораспаковка выполняются:
* с помощью оператора "=";
* когда аргумент передаётся методу или значение возвращается из метода.

Особенность целочисленных классов-обёрток, созданных автоупаковкой констант в диапазоне -128..+127 - они кэшируются JVM.
Потому такие обёртки с одинаковыми значениями являются ссылками на один и тот же объект.

## Аннотации (метаданные)

**Аннотации** - это информация (синтаксические метаданные), добавленная в исходный код.

Аннотации не влияют на выполнение кода, но используются компилятором и разными инструментами разработки для анализа кода,
генерации кода, компиляции, развёртывания, выполнения. Появились в JDK 5.

**Функции аннотаций**:
* дают необходимую информацию для компилятора / интерпретатора;
* дают информацию различным инструментам для генерации другого кода, конфигураций и т.д.;
* могут использоваться во время выполнения для получения данных через отражение (reflection).

Аннотировать можно объявление пакетов, классов, методов, переменных, параметры методов, константы перечислимого типа,
другие аннотации.

**Создание аннотации** (объявление типа аннотации) **основано на интерфейсе**.

**Ограничения**, накладываемые на объявление типа аннотации:
* Одна аннотация не может наследовать другую;
* Аннотация содержит только объявления методов без параметров и без определения их тела.
  Эти методы ведут себя аналогично полям;
* Методы аннотации должны возвращать только следующие типы данных:
  * примитивные типы (byte, short, int, long, char, float, double, boolean);
  * Class, String;
  * перечисление (enum);
  * другой тип аннотации (аннотацию);
  * массив одного из перечисленных выше типов.
* Аннотации не могут быть обобщёнными (не могут принимать параметры типа);
* Объявления методов в аннотации не могут содержать оператор throws.

Аннотация автоматически расширяет интерфейс `java.lang.annotation.Annotation`, который является суперинтерфейсом 
для всех аннотаций. В нём переопределены методы hashCode(), equals() и toString() класса Object,
а также объявлен метод annotationType().

**Объявление типа аннотации**
```
// Объявление типа аннотации
@interface имя_типа_аннотации {
    тип_члена_1 имя_члена_1() default значение_по_умолчанию;
    тип_члена_n имя_члена_n() default значение_по_умолчанию;
}

// Пример объявления типа аннотации
@interface MyAnno {
    String str() default "Default value";
    int val();
}

// Аннотирование метода myMeth
@MyAnno(str = "Пример аннотации", val = 300) // инициализация членов аннотации
public static void myMeth() {
    // ...
}
```

### Правила удержания аннотаций

Правила удержания аннотации определяют момент, когда аннотация отбрасывается (становится недоступной).
Они определены в перечислении `java.lang.annotation.RetentionPolicy`:
* SOURCE - аннотация содержится только в исходном файле и отбрасывается при компиляции;
* CLASS - аннотация сохраняется в файле с расширением .class во время компиляции, 
  но недоступна для виртуальной машины JVM во время выполнения;
* RUNTIME - аннотация сохраняется в файле с расширением .class во время компиляции и остаётся доступной для виртуальной
  машины JVМ во время выполнения. Она может быть получена во время выполнения с помощью рефлексии.

Если для аннотации не указано никакого правила удержания, то применяется правило удержания CLASS.

Правило удержания аннотации задаётся с помощью встроенной аннотации @Retention.
```
@Retention (правило_удержания) // правило_удержания = SOURCE, CLASS или RUNTIME

// например, объявление типа аннотации MyAnno с правилом удержания RUNTIME:

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
    String str();
    int val();
}
```

### Получение аннотаций во время выполнения с помощью рефлексии

Если аннотация объявлена с правилом удержания RUNTIME, то она может быть получена во время выполнения с помощью рефлексии.

**Рефлексия** - это языковое средство для получения информации о классе во время выполнения программы.

Прикладной программный интерфейс (API) для рефлексии входит в состав пакета `jаva.lang.reflect`.

**Последовательность использования рефлексии**:
* Получить объект типа Class (java.lang.Class) методом getClass(), объявленным в классе Object:
```
   final Class<?> getClass();
```
* Использовать методы класса Class для получения информации об элементах, объявленных в классе: методах, полях, 
  конструкторах, аннотациях (getMethod(), getField(), getConstructor(), getAnnotation()):
```
   Method getMethod(String имя_метода, Class<?> ... типы_параметров); // список аргументов переменной длины
   Field getField(String имя_поля);
   Constructor<T> getConstructor(Class<?> ... типы_параметров);
   <T extends Annotation> T getAnnotation(Class<T> тип_аннотации);
   Method[] getMethods();
   Field[] getFields();
   Constructor<?>[] getConstructors();
   Annotation[] getAnnotations(); // может быть вызван у объектов типа Package, Class, Method, Constructor и Field
```

Рефлексию в аннотациях поддерживает интерфейс `java.lang.reflect.AnnotatedElement`.
В нём определены методы getAnnotation(), getAnnotations(), getDeclaredAnnotation(), getDeclaredAnnotations(),
isAnnotationPresent(), getAnnotationsByType(), getDeclaredAnnotationsByType().
Эти методы реализованы в классах Package, Class, Method, Constructor и Field.

### Виды аннотаций

* **Обычная аннотация**, рассмотренная выше.
* **Аннотация-маркер** - аннотация, которая не содержат членов. Единственное назначение - пометить объявление.
```
// Объявление аннотации-маркера
@interface MyAnnoMarker { }

// Аннотирование аннотацией-маркером
@MyAnnoMarker() // при аннотировании необязательно указывать скобки после имени аннотации-маркера
void annotatedMethod() {
    // ...
}
```
* **Одночленная аннотация** - аннотация, которая состоит из единственного члена.
  Подобна обычной аннотации, но допускает сокращённую форму указания члена аннотации:
  если задать имя члена как "value", то при аннотировании указывать имя члена необязательно.
```
// Объявление одночленной аннотации
@interface MyAnnoOneMember {
    int value(); // имя единственного члена должно быть "value"
}

// Аннотирование одночленной аннотацией
// при аннотировании необязательно указывать имя единственного члена (с именем "value"), а только значение
@MyAnnoOneMember(300)
void annotatedMethod() {
    // ...
}
```
Такой синтаксис можно применять и в аннотации, у которой несколько членов, 
но только один имеет имя "value", а остальные имеют другие имена и значения по умолчанию (помечены как default):
```
// Объявление аннотации
@interface MyAnno {
    int value();
    int     abc() default 100;
    String  str() default "Default string";
}

// Варианты аннотирования
@MyAnno(300) // значение члена value = 300, остальных - по умолчанию
@MyAnno(value = 300, abc = 123, str = "New string") // если нужно задать значения остальным членам (не по умолчанию)
```

* **Встроенные аннотации**, расположенные в пакетах `java.lang`, `java.lang.annotation`;
  имеют общее или специальное назначение. Далее описаны встроенные аннотации общего назначения.
  
  Из пакета `java.lang.annotation`:
  * @Retention - аннотация к другой аннотации, определяет правило удержания (SOURCE, CLASS, RUNTIME);
  * @Documented - аннотация к другой аннотации, сообщает средству разработки, что аннотация должна быть документирована;
  * @Target - аннотация к другой аннотации, задаёт типы элементов, к которым можно применять аннотацию. Тип элемента
    указывается в аргументе аннотации, например: `@Target({ ElementType.FIELD, ElementType.LOCAL_VARIABLE})`. 
    Если значение аргумента аннотации не указано, то аннотацию можно применять к любому объявляемому элементу,
    кроме параметра типа (TYPE_PARAMETER).
    Можно задать одно (или несколько значений через запятую в фигурных скобках) из перечисления `ElementType`:
    * TYPE - класс, интерфейс или перечисление;
    * FIELD - поле;
    * METHOD - метод;
    * PARAMETER - параметр;
    * CONSTRUCTOR - конструктор;
    * LOCAL_VARIABLE - локальная переменная;
    * ANNOTATION_TYPE - другая аннотация;
    * PACKAGE - пакет;
    * TYPE_PARAMETER - параметр типа (добавлено в JDK 8);
    * TYPE_USE - использование типа (добавлено в JDK 8).
  * @Inherited - аннотация-маркер к другой аннотации в объявлении класса - позволяет аннотации наследоваться.
    При наследовании класса проверяется наличие аннотации у суперкласса и она может быть получена у подкласса;
  * @Repeatable - аннотация для поддержки повторяющихся аннотаций (добавлена в JDK 8);
  * @Native - аннотация для аннотирования полей, доступных из платформенно-ориентированного кода (добавлена в JDK 8);
  
  Из пакета `java.lang`:
  * @Override - аннотация-маркер, применяется к методам; 
    аннотированный метод _должен переопределять_ метод из суперкласса, иначе будет ошибка компиляции;
  * @Deprecated - аннотация-маркер обозначает, что объявление устарело и должно быть заменено новой формой;
  * @FunctionalInterface - аннотация-маркер, применяется к интерфейсам (добавлена в JDK 8); обозначает, что
    аннотируемый интерфейс является _функциональным_, т.е. содержит только один метод (абстрактный); необязательна 
    для функционального интерфейса. Но если аннотированный интерфейс не является функциональным, то ошибка компиляции;
  * @SafeVarargs - аннотация-маркер, применяется в методах и конструкторах (объявляемым как static или final)
    _с переменым количеством аргументов_. Она указывает, что код безопасен и подавляет непроверяемые предупреждения;
  * @SuppressWarnings - аннотация подавляет предупреждения компилятора; задаётся одно или несколько имён предупреждений.

* **Типовая аннотациия** (аннотация типа) - расширенная возможность применения аннотации везде,
  где применяются типы данных, а не только в объявлении как раньше (добавлена в JDK 8).
  Аннотируется с помощью аннотации `@Target(ElementType.TYPE_USE)`.
  
  Можно аннотировать:
  * тип данных, возвращаемый методом (кроме типа void);
  * тип объекта по ссылке this в теле метода (начиная с JDК 8 ссылку this можно явно указывать в качестве параметра 
    в объявлении метода экземпляра ради применения типовой аннотации);
  * приведение типов;
  * уровни доступа к массиву;
  * наследуемый класс;
  * оператор throws;
  * обобщённые типы, включая границы параметров и аргументы обобщенного типа (обобщения).
```
// Пример объявления типовой аннотации @TypeAnno:
@Target(ElementType.TYPE_USE)
@interface TypeAnno { }

// Аннотирование исключения NullPointerException в операторе throws:
void myMeth() throws @TypeAnno NullPointerException {
    // ...
}
```

* **Повторяющаяся аннотация** - возможность повторять аннотацию в одном и том же элементе (добавлена в JDK 8).
  Она аннотируется с помощью встроенной аннотации `@Repeatable` из пакета `java.lang.annotation`.
  В аннотации `@Repeatable` (в её поле "value") указывается тип контейнера для повторяющейся аннотации.
  Тип контейнера - это заранее созданная контейнерная аннотация.
  Т.е. сначала создаётся контейнерная аннотация, затем она указывается в аннотации `@Repeatable` (в поле "value"), 
  а уже аннотация `@Repeatable` аннотирует повторяющуюся аннотацию.
  
  Способы получения повторяющихся аннотаций (с помощью методов из интерфейса `java.lang.reflect.AnnotatedElement`):
  * получение _контейнерной аннотации_ с помощью метода `getAnnotation()` или `getDeclaredAnnotation()`; затем вызов
    метода toString() у экземпляра полученной аннотации возвращает _повторяющиеся аннотации_, разделённые запятыми;
  * использование метода `getAnnotationsByType()` или `getDeclaredAnnotationsByТуре()` (добавлены в JDK 8):
    * `<T extends Annotation> T[] getAnnotationsByType(Class<T> тип_аннотации)` - возвращает массив связанных 
      с вызывающим объектом аннотаций, имеющих заданный тип_аннотации; если таких аннотаций нет, то метод возвращает 
      массив нулевой длины;
    * `<T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> тип_аннотации)` - то же самое, 
      но отличие - игнорирует унаследованные аннотации.
