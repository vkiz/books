# Глава 2. Краткий обзор Java

В этой главе представлен краткий обзор основных языковых средств языка Java. Этот материал служит отправной точкой,
позволяя создавать и понимать простые программы. Подробное рассмотрение языка приведено в остальных главах.

## Объектно-ориентированное программирование

Объектно-ориентированное программирование (ООП) - методология программирования, основанная на представлении программы 
в виде совокупности объектов, каждый из которых является экземпляром определенного класса, а классы образуют иерархию 
наследования. ООП составляет основу языка Java.
Ниже рассмотрены методики создания программ, элементы, принципы ООП.

### Две методики создания программ

Все компьютерные программы состоят из двух элементов: кода и данных.
Две методики создания программ:
* Модель, ориенированная на процессы - программа представляет собой последовательность линейных шагов (кода).
Это код, воздействующий на данные. Такая модель применяется в процедурных языках (например, C);
* Объектно-ориентированное программирование - программа представляет собой совокупность данных (объектов) и набора
интерфейсов для работы с этими данными. Это данные, управляющие доступом к коду.

### Абстракция

Абстракция - важный элемент ООП.
Абстракция позволяет представить данные сложной программы в виде иерархии объектов, имеющих своё поведение.
Данные - поля класса, поведение - методы класса.
Последовательность этапов программы реализуется передачей сообщений между объектами.

### Три принципа ООП

Принципы ООП - это механизмы, с помощью которых реализуется объектно-ориентированная модель.
Это: инкапсуляция, наследование, полиморфизм.

* **Инкапсуляция** (англ. encapsulation, от лат. in capsula - в капсуле, т.е. размещение в оболочке, изоляция) - 
это механизм, связывающий код и данные, которыми манипулирует этот код и защищающий данные от внешнего вмешательства.
**Основой инкапсуляции является класс.** Класс определяет структуру (данные) и поведение (код) объекта (экземпляра класса).
Данные и код класса называют _членами класса_. Данные класса называют _переменными-членами_ или _переменными экземпляра_
класса. Код, оперирующий данными, называют _методами-членами_ или просто _методами_.
Инкапсуляция защищает код и данные класса от внешнего кода. **Защита реализуется путём создания продуманного 
интерфейса класса**, т.е. защищённых внутренних переменных класса и открытых методов класса для доступа к защищённым
переменным. Для этого каждая переменная и метод класса могут быть помечены как закрытые или открытые с помощью трёх
ключевых слов - модификаторов доступа **private, protected, public**, определяющих разные уровни доступа.

* **Наследование** (англ. inheritance) - процесс получения свойств одним объектом (потомком) от другого (родительского).
Наследование обеспечивает принцип иерархической (т.е. нисходящей) классификации объектов. Это позволяет производному 
объекту получить все свойства родительского и добавить только лишь свойства, определяющие его специализацию.
Класс, производящий наследование, называют базовым, родительским, суперклассом (англ. base class).
Класс, наследуемый от базового, называют потомком, наследником, дочерним, производным (англ. derived class).
При наследовании класс получает все методы, свойства и события базового класса такими, какими они реализованы в базовом 
классе.

* **Полиморфизм** (от греч. poly - много + morphe - форма, т.е. имеющий много форм) - механизм, позволяющий использовать 
объекты с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
Он позволяет использовать один и тот же интерфейс для общего вида действий разных типов данных (классов). 
Выбор конкретного действия (метода класса) применительно для каждой ситуации выполняется компилятором.
"Один интерфейс, несколько реализаций".

  Полиморфизм - это способность представить тот же интерфейс для различных форм (типов данных), лежащих в основе. 
  Это означает, что классы имеют различную функциональность, несмотря на то, что используют общий интерфейс и могут быть 
  вызваны динамически через специальную ссылку класса.
  
  Обьект может использовать методы производного класса, т.е. можно использовать наследников, как родителей.
  Если в классе-наследнике был переопределен (override) какой-то метод, то вызовется он. Это способность к изменению 
  функциональности, унаследованной от базового класса.
  Важно не путать: override - перекрытие метода в дочернем классе (используется полиморфизмом);
  overload - перегрузка методов, то есть создание методов с одним названием, но отличающихся аргументами (не относится
  к полиморфизму).
  
  Классический пример: класс Shape (фигура) и классы Square, Circle (квадрат, окружность), которые наследуются от него. 
  Каждый класс имеет свою собственную функцию getArea() и клиентский код может выполнять следующие действия:
  ```
  Shape shape1 = new Square();
  shape1.getArea();
  Shape shape2 = new Circle();
  shape2.getArea();
  ```

  **О полиморфизме из других источников**

  * **Полиморфизм интерфейсов**
  
    Интерфейсы описывают методы, которые должны быть реализованы в классе, и типы параметров, которые должен получать и 
    возвращать каждый член класса, но не содержат определенной реализации методов, оставляя это реализующему интерфейс 
    классу. В этом и заключается полиморфизм интерфейсов. Несколько классов могут реализовывать один и тот же интерфейс, 
    в то же время один класс может реализовывать один или больше интерфейсов. Интерфейсы находятся вне иерархии 
    наследования классов, поэтому они исключают определение метода или набора методов из иерархии наследования.
    
  * **Полиморфизм наследования**
  
    При наследовании класс получает все методы, свойства и события базового класса такими, какими они реализованы 
    в базовом классе. При необходимости в наследуемых классах можно определять дополнительные члены или переопределять 
    члены, доставшиеся от базового класса, чтобы реализовать их иначе. Наследуемый класс также может реализовывать 
    интерфейсы. В данном случае полиморфизм проявляется в том, что функционал базового класса присутствует в наследуемых
    классах неявно. Функционал может быть дополнен и переопределен. А наследуемые классы, несущие в себе этот функционал
    выступают в роли многих форм.
    
  * **Полиморфизм при помощи абстрактных классов**
  
    Абстрактные классы поддерживают как наследование, так и возможности интерфейсов. При построении сложной иерархии, 
    для обеспечения полиморфизма программисты часто вынуждены вводить методы в классы верхнего уровня при том, 
    что эти методы ещё не определены. Абстрактный класс - это класс, экземпляр которого невозможно создать; 
    этот класс может лишь служить базовым классом при наследовании. Нельзя объявлять абстрактные конструкторы или 
    абстрактные статические методы. Некоторые или все члены этого класса могут оставаться нереализованными, 
    их реализацию должен обеспечить наследующий класс. Производные классы, которые не переопределяют все абстрактные 
    методы, должны быть отмечены как абстрактные. Порожденный класс может реализовывать также дополнительные интерфейсы.
    
  * **Полиморфизм методов**
  
    Способность классов поддерживать различные реализации методов с одинаковыми именами - один из способов реализации 
    полиморфизма. Различные реализации методов с одинаковыми именами в Java называется перегрузкой методов. 
    На языках, которые не поддерживают перегрузку методов, каждому методу необходимо давать уникальное имя. На практике 
    часто приходится реализовывать один и тот же метод для различных типов данных. Право выбора специфической версии 
    метода предоставлено компилятору.
    
    Отдельным вариантом полиморфизма методов является _полиморфизм методов с переменным числом аргументов_, 
    введенный в версии J2SE 5. Перегрузка методов здесь предусмотрена неявно, т.е. перегруженный метод может вызываться 
    с разным числом аргументов, а в некоторых случаях даже без параметров.
    Перегрузка методов, как правило, делается для тесно связанных по смыслу операций. Ответственность за построение 
    перегруженных методов и выполнения ими однородных по смыслу операций лежит на разработчике.
  
  * **Полиморфизм через переопределение методов**
  
    Если перегруженные методы с одинаковыми именами находятся в одном классе, списки параметров должны отличаться. 
    Но если метод подкласса совпадает с методом суперкласса (порождающего класса), то метод подкласса переопределяет 
    метод суперкласса. Совпадать при этом должны и имена методов и типы входных и выходных параметров. В данном случае 
    переопределение методов является основой концепции _динамического связывания (или позднее связывание)_, 
    реализующей полиморфизм. Суть _динамической диспетчеризации методов_ состоит в том, что решение на вызов 
    переопределенного метода принимается во время выполнения, а не во время компиляции. 
    Однако final-методы не являются переопределяемыми, их вызов может быть организован во время компиляции 
    и называется _ранним связыванием_.
    
    В Java все методы используют позднее связывание, если вы не отметите их явно как final.
    Финальные методы не могут быть переопределены и вызываются быстрее. Тот факт, что в Java по умолчанию используется 
    позднее связывание, тогда как в C++ стандартом является раннее связывание, - явный признак разного подхода языков: 
    C++ временами жертвует объектно-ориентированной моделью в пользу эффективности, тогда как Java - наоборот.
    
    Пример, который иллюстрирует динамическую диспетчеризацию методов:
    ```java
    class A {
     void callme() {
      System.out.println("Метод callme класса A");
     }
    }
    class B extends A {
     // Переопределить callme
     void callme() {
      System.out.println("Метод callme класса B");
     }
    }
    class C extends A {
     // Переопределить callme
     void callme() {
      System.out.println("Метод callme класса С");
     }
    }
    class Dispatch {
     public static void main(String args[]) {
      A a = new A();        // объект типа A
      B b = new B();        // объект типа B
      C c = new C();        // объект типа C
      A r;                  // определить ссылку типа A
  
      r = a;                // r указывает на A-объект
      r.callme();           // вызывает A-версию callme
  
      r = b;                // r указывает на B-объект
      r.callme();           // вызывает B-версию callme
  
      r = c;                // r указывает на C-объект
      r.callme();           // вызывает C-версию callme
     }
    }
    ``` 
    Вывод программы:
    ```
    Метод callme класса A
    Метод callme класса B
    Метод callme класса C
    ```
  
  * **Полиморфизм через динамическое определение типов** (Run-time type information, Run-time type identification, RTTI)
  
    Java позволяет узнать точный тип объекта, когда у вас есть ссылка только на базовый тип. Для этого в Java встроено 
    безопасное преобразование типов (type-safe downcast). Cинтаксис безопасного преобразования типов:
    ```
    Dog MyDog = (Dog) myAnimal;
    ```
    В случае ошибки выбрасывается исключение.
    
    В Java тип объекта может быть получен при помощи метода getClass(), объявленного в классе java.lang.Object и потому 
    реализуемого каждым классом. Для проверки принадлежности объекта определенному типу используется оператор instanceof. 
  
  * **Полиморфизм представлений**
  
    Известно, что в ряде ситуаций полезен _полиморфизм представлений_, когда один объект имеет несколько представлений, 
    оптимизированных для выполнения специфических операций. В идеале эти представления должны поддерживаться на 
    протяжении всего жизненного цикла объекта. Авторы Java предложили частичное решение проблемы 
    полиморфизма представлений, введя "копирующие" конструкторы, создающие новый экземпляр коллекции из элементов 
    существующего набора, быть может, отличающегося реализацией. 
    Например, конструктор TreeSet(Collection c) позволяет представить коллекцию c в виде экземпляра класса TreeSet.
    
  * **Дополнительно, кратко**
    
      Полиморфизм - один интерфейс, много реализаций.
      
      Полиморфизм - возможность приведения типа потомка к типу родителя. Потомок обязан предоставить интерфейс родителя, 
      а как он это сделает - будет или нет переопределять (override) методы родителя безразлично. При этом речь идёт 
      о методах в разных классах (в классах-родителях и классах-потомках). Данный вопрос связан с наследованием.
      
      _Переопределение_ с наследованием (override) - частный случай полиморфизма (динамический полиморфизм).
      
      _Перегрузка_ (overload) - возможность создать разные методы с одним названием но разными входными параметрами.
      В данном случае методы реализуются в одном классе и речи об отношениях родитель-потомок вообще нет.
      К наследованию это не имеет отношения, перегрузка - не полиморфизм.

### Программа на языке Java

Исходный код программы на языке Java размещается в текстовом файле с расширением **.java**.
Файл с исходным кодом Java официально называется _единицей компиляции_. Он содержит определение одного 
или нескольких классов. Имя главного класса должно строго совпадать с именем файла, содержащего его исходный код.

**Компиляция программы**

Для компиляции программы используется компилятор **javac**, входящий в состав комплекта средств разработки JDK 8
(Java Development Kit, JDK) и предоставляемый Oracle Corporation.
Компилятор javac создаёт для каждого класса отдельный файл с расширением **.class**, содержащий **байт-код** 
определённой версии. Байт-код содержит инструкции, которые будет выполнять _виртуальная машина JVM_. Для запуска 
выполнения программы используется _загрузчик приложений_, который называется java.
```
C:\>javac Example.java
C:\>java Example
```

### Синтаксис Java

Основу языка образуют ключевые слова, операторы и разделители.

**Комментарии** - примечания к коду программы в файле исходного кода
  * Однострочный        `// Комментарий`
  * Многострочный       `/* Комментарий */`
  * Документирующий     `/** @author Vladimir */`

**Блоки кода**
  * Начало блока        `{`
  * Конец блока         `}`

**Пробелы** - символы пробела, табуляции или новой строки - разделяют ещё не разграниченные оператором или разделителем 
лексемы.

**Идентификаторы** - имена классов, методов и переменных. Идентификатором может быть любая последовательность
строчных и прописных букв, цифр, символов подчёркивания и денежной единицы ($, не предназначен для общего использования).
Идентификатор не может начинаться с цифры, чтобы компилятор не путал его с числовыми константами. Учитывается регистр
символов.
Примеры идентификаторов: VALUE, Value, AvgTemp, count, a4, $test, this_is_ok

**Литералы** - значение переменной, например: 300 - целочисленное значение; 100.5 - числовое значение с плавающей точкой;
'A'- символьная константа; "This is a string" - строковое значение.

**Разделители**
  * Круглые скобки      `( )`       Передача параметров в определениях и вызовах методов; обозначение операции приведения
    типов; предшествование операторов в выражениях, употребляемых в управляющих операторах;
  * Фигурные скобки     `{ }`       Определение блоков кода, классов, методов, локальных областей действия; указание
    значений автоматически инициализируемых массивов;
  * Квадратные скобки   `[ ]`       Объявление массивов; обращение к элементам массива;
  * Точка с запятой     `;`         Завершение оператора;
  * Запятая             `,`         Разделение идентификаторов в объявлении переменных; создание цепочек операторов в
    операторе цикла for;
  * Точка               `.`         Отделение имён пакетов от подпакетов и классов; отделение переменной или метода от
    ссылочной переменной.

**Ключевые слова Java**

|          |          |            |           |              |
|----------|----------|------------|-----------|--------------|
| abstract | continue | for        | new       | switch       |
| assert   | default  | goto       | package   | synchronized |
| boolean  | do       | if         | private   | this         |
| break    | double   | implements | protected | throw        |
| byte     | else     | import     | public    | throws       |
| case     | enum     | instanceof | return    | transient    |
| catch    | extends  | int        | short     | try          |
| char     | final    | interface  | static    | void         |
| class    | finally  | long       | strictfp  | volatile     |
| const    | float    | native     | super     | while        |

Кроме ключевых слов, в Java спецификацией языка зарезервированы также слова: true, false, null.

Среда Java в целом состоит из самого языка Java и его стандартных классов, сгруппированных в библиотеки классов.
