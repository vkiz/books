# Глава 14. Обобщения

**Обобщения - это параметризованные типы**, позволяющие объявлять классы, интерфейсы и методы, где тип данных, которыми 
они оперируют, указан в виде параметра. Добавлены в JDK 5. Обобщения обеспечивают типовую безопасность.

Классы, интерфейсы и методы, оперирующие параметризованными типами, называются _обобщёнными_.

## Обобщённый класс

**Объявление обобщённого класса**:
```
class имя_обобщённого_класса<список_параметров_типа> {
    // ...
}

// обобщённый класс Generic с одним параметром типа
// T - параметр типа, который будет заменён реальным типом при создании экземпляра класса Generic
class Generic<T> {
    T obj;
    Generic(T o) { // конструктор класса
        obj = o;
    }
}

// обобщённый класс Generic2 с двумя параметрами типа
class Generic2<T,V> {
    T obj1;
    V obj2;
    Generic2(T o1, V o2) {
        obj1 = o1;
        obj2 = o2;
    }
}
```
**Создание экземпляра обобщённого класса**:
```
имя_обобщённого_класса<список_аргументов_типа> имя_переменной = new имя_обобщённого_класса<список_аргументов_типа>(список_аргументов_конструктора);

Generic<Integer> intObj = new Generic<Integer>(300);
Generic2<Integer, String> genObj = new Generic2<Integer, String>(300, "Строковое значение");

// начиная с JDK 7 в new можно использовать пустой список аргументов типа - это "ромбовидный оператор"
Generic<Integer> genObj1 = new Generic<>(300);
Generic2<Integer, String> genObj2 = new Generic2<>(300, "Строковое значение");
```

## Свойства и ограничения обобщений

* Аргумент, передаваемый в параметр типа, должен быть ссылочного типа (например, не примитивного int, а оболочки типа Integer);
* Обобщённые типы различаются по аргументам типа. Ссылка на одну конкретную версию обобщённого типа несовместима 
  с другой версией того же самого обобщённого типа - они являются ссылкам и на разные типы объектов.
  Этим обобщения обеспечивают типовую безопасность;
* Нельзя создать экземпляр по параметру типа: `class Gen<T> { T obj; Gen() { obj = new T(); } }` // ошибка
* В статических членах класса нельзя использовать параметр типа, _объявленный в этом классе_.
  Но объявить статические обобщённые методы _со своими_ параметрами типа можно.
  `class Gen<T> { static T obj; static T getObj() { return obj; } }` // ошибка
* Ограничения на обобщенные массивы:
  * нельзя создать экземпляр массива, тип элемента которого определяется параметром типа;
  * нельзя создать массив специфических для типа обобщённых ссылок.
* Обобщённый класс не может расширять класс Throwable. Это значит, что нельзя создать обобщённые классы исключений.

## Ограниченный тип

**Ограниченный тип** - это параметр типа обобщённого класса, который может быть заменён только указанным суперклассом 
или его подклассами. Он создаётся путём указания (в параметре типа) _суперкласса_, от которого должен быть унаследован 
аргумент типа. Можно также использовать один или несколько _интерфейсов_ или одновременно _суперкласс и интерфейс(ы)_,
объединив их логической операцией "И" (символ &):
```
class имя_обобщённого_класса<T extends имя_суперкласса>
class имя_обобщённого_класса<T extends имя_интерфейса>
class имя_обобщённого_класса<T extends имя_суперкласса & имя_интерфейса_1 & имя_интерфейса_n>

// параметр типа Т может быть заменён только суперклассом Number или его подклассами (например, Integer, Double и т.д.)
class GenericNumber<T extends Number>
```

## Метасимвольный аргумент

**Метасимвольный аргумент** - это языковое средство обобщённого класса (символ ?), представляющее неизвестный тип аргумента.

Метасимвол ? просто совпадает в любым достоверным объектом обобщённого класса, но не влияет на тип создаваемых объектов
этого класса.
```
boolean sameAverage(GenericNumber<?> obj) {
    if (average() == obj.average())
        return true;
    return false;
}
```

## Ограниченный метасимвольный аргумент

**Ограниченный метасимвол** задаёт верхнюю или нижнюю границу для аргумента типа. Это позволяет ограничить типы объектов, 
которыми будет оперировать метод.
```
// задание верхней границы для аргумента типа - допустимы типы суперкласса и его подклассов
<? extends  имя_суперкласса>

// задание нижней границы для аргумента типа - допустимы только суперклассы указанного подкласса (не включая подкласс)
<? super    имя_подкласса>
```

## Обобщённый метод

Можно объявить обобщённый метод, в  котором используется один или несколько параметров типа.
Обобщённый метод _может быть_ даже членом обычного (необобщённого) класса.

```
<список_параметров_типа_через_запятую>  возвращаемый_тип  имя_метода  (список_параметров_метода) {
    // тело метода
}

static <T extends Comparable<T>, V extends T> boolean isInArray(T x, V[] y) {
    for (int i = 0; i < y.length; i++) {
        if (x.equals(y[i])) {
            return true;
        }
    }
    return false;
}
```

## Обобщённый конструктор

Можно объявлять обобщённый конструктор, даже если его класс не является обобщённым.

```
class GenericConstructor {                              // необобщённый класс
    private double val;
    
    <T extends Number> GenericConstructor(T arg) {      // обобщённый конструктор
        val = arg.doubleValue();
    }
}
```

## Обобщённый интерфейс

Обобщённый интерфейс объявляется таким же образом, как и обобщённый класс.
Класс, реализующий обобщённый интерфейс, _не обязан_ быть обобщённым.

**Объявление обобщённого интерфейса**:
```
interface имя_обобщённого_интерфейса<список_параметров_типа> {
    // ...
}

interface MinMax<T extends Comparable<T>> {
    T getMin();
    T getMax();
}

// класс, реализующий обобщённый интерфейс
class имя_класса<список_параметров_типа> implements имя_обобщённого_интерфейса<список_аргументов_типа> {
    // ...
}
```

## Базовый тип

**Базовый тип** (сырой, raw) - это применение обобщённого класса без аргумента типа.

Базовый тип совместим с унаследованным кодом (где нет обобщений), но _утрачивается типовая безопасность_, т.е.
при приведении типов, несовместимых друг с другом не будет ошибки компиляции, но будет ошибка во время выполнения.
Правильность выбора типа при приведении типов приходится контролировать программисту, а не компилятору.

```
// например, есть обобщённый класс
class Generic<T> { // ... }
// выполняется создание объекта _базового типа_ Generic ("сырого", т.е. без аргумента типа)
Generic raw = new Generic(new Double(123.45));
```

## Наследование обобщённых классов

* **Обобщённый суперкласс**. 
  В подклассе (обобщённом) обязательно должны быть объявлены параметры типа, требующиеся его обобщённому суперклассу
  (они наследуются). Подкласс, если ему требуется, может быть дополнен своими дополнительными параметрами типа.
* **Обобщённый подкласс**. 
  Его суперклассом может быть и обычный (необобщённый) класс.
* **Сравнение типов** объектов в иерархии обобщённых классов во время выполнения возможно с помощью оператора instanceof.
  Оператор instanceof определяет, является ли объект экземпляром указанного класса или его родительских классов.
  Во время выполнения всякие сведения об обобщённом типе отсутствуют (о конкретном аргументе типа) (см. _стирание_).
* **Приведение типов** (обобщённых классов) возможно, если они совместимы и их аргументы типа одинаковы.
* **Переопределение методов обобщённого класса** такое же, как и любых других методов.

## Выведение типов - ромбовидный оператор

Начиная с версии JDК 7 можно использовать сокращённый синтаксис для создания экземпляра обобщённого класса.
В new можно использовать пустой список аргументов типа, т.е. просто пустые угловые скобки - это "ромбовидный оператор".
Этот оператор предписывает компилятору самому _вывести тип аргументов_, требующихся конструктору в операторе new.

```
имя_обобщённого_класса<список_аргументов_типа> имя_переменной = new имя_обобщённого_класса<>(список_аргументов_конструктора);

Generic<Integer> genObj1 = new Generic<>(300);
Generic2<Integer, String> genObj2 = new Generic2<>(300, "Строковое значение");
```

## Стирание

**Стирание** - это способ представления обобщений в байт-коде (в JVM), при котором для обеспечения совместимости 
с старым кодом все сведения об обобщённых типах удаляются (стираются) при компиляции.

Стирание означает, что никаких сведений о типах обобщений во время выполнения не существует.
Это просто механизм автоматической обработки исходного кода при компиляции.

Принцип действия стирания:
* сначала параметры типа заменяются их ограничивающим типом Object, если никакого явного ограничения не указано;
* затем выполняется требуемое приведение типов, определяемое аргументами типа, для обеспечения совместимости типов.

Когда два внешне разных объявления в обобщении при стирании приводятся компилятором к одному и тому же типу,
то возникает **ошибка неоднозначности**. Например:
```
class Generic<T,V> {
    T obj1;
    V obj2;
    // эти два перегружаемых метода неоднозначны и не компилируются
    // стирание типов приводит оба варианта метода set() к одному и тому же виду: void set(Object o) { // ... }
    void set(T o) { obj1 = o; }
    void set(V o) { obj2 = o; }
}
```

## Мостовой метод

**Мостовой метод** - это вспомогательный метод, который создаёт компилятор на уровне байт-кода.
Мостовой метод недоступен для программиста и не может быть явно вызван.
Он создаётся в случае, когда результат стирания типов в перегружаемом методе из подкласса не совпадает с тем, что 
получается при стирании в аналогичном методе из суперкласса. В этом случае компилятор создаёт метод, который использует 
стирание типов в суперклассе и вызывает соответствующий метод из подкласса с указанным стиранием типов.
