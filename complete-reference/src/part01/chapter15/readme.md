# Глава 15. Лямбда-выражения

**Лямбда-выражение** - это анонимный (безымянный) метод. Он реализует метод, определённый в _функциональном интерфейсе_.

**Функциональный интерфейс** - это интерфейс, который содержит только один метод (абстрактный, без реализации по умолчанию).
В функциональном интерфейсе определяется _целевой тип_ лямбда-выражения.

Лямбда-выражение приводит к некоторой форме анонимного класса. Экземпляр класса, реализующего функциональный интерфейс, 
создается автоматически когда лямбда-выражение появляется в контексте своего целевого типа.

Лямбда-выражение называют также _замыканием_.

**Лямбда-оператор** (операция "стрелка" `->` буквально означает "становиться", "переходить"), добавлен в JDK 8.

Лямбда-оператор разделяет лямбда-выражение на две части:
* в **левой** части указываются любые **параметры**, требующиеся в лямбда-выражении (или пустой список если параметры не требуются);
* в **правой** части находится **тело** лямбда-выражения, где указываются действия, выполняемые лямбда-выражением.
  Тело лямбда-выражения может быть _двух видов_:
  * _тело выражения_ - это тело, состоящее из единственного выражения (лямбда-выражения называются одиночными);
  * _тело блока_ - это тело, состоящее из блока кода (лямбда-выражения называются блочными).

```
// лямбда-выражения без параметров
() -> 123.45                // возвращает значение константы
() -> Math.random() * 100   // возвращает произведение случайного числа на 100

// лямбда-выражение с параметром n (количество параметров - любое; тип можно не указывать, он выводится из контекста)
(n) -> (n % 2) == 0         // возвращает логическое значение true, если значение параметра n оказывается чётным
```

Лямбда-выражение может быть указано только в том **контексте**, в котором определён его целевой тип:
* когда лямбда-выражение присваивается ссылке на функциональный интерфейс;
* в инициализации переменных и массивов;
* в аргументе метода (аргумент должен иметь тип функционального интерфейса, совместимого с лямбда-выражением);
* в операторе return;
* в приведении типов;
* в тернарной операции `? :`;
* в лямбда-выражениях.
```
// объявление функционального интерфейса
// метод getValue() без реализации по умолчанию, поэтому он неявно абстрактный (модификатор abstract необязателен)
interface MyNumber {
    double getValue();
}

// объявление ссылки на функциональный интерфейс
MyNumber myNum;

// лямбда-выражение присваивается ссылке на функциональный интерфейс
myNum = () -> 123.45;
```

## Возможности и ограничения лямбда-выражений

* Лямбда-выражение не может быть обобщённым (нельзя указывать параметры типа в самом лямбда-выражении).
  Но обобщённым может быть функциональный интерфейс, связанный с лямбда-выражением.
  
* Лямбда-выражение можно передавать в качестве аргумента функции.

* Лямбда-выражение может генерировать исключение. Исключение должно быть совместимо с исключениями, перечисленными 
  в выражении throws из объявления абстрактного метода в функциональном интерфейсе.
  
* В лямбда-выражении можно использовать (получить или установить значение) переменные - _поля класса_ 
  (содержащего это лямбда-выражение):
  * переменную экземпляра;
  * статическую переменную;
  * ссылку this класса и вызывать методы класса.

* В лямбда-выражении можно использовать (только получить значение) _действительно завершённой локальной переменной_, 
  объявленной в объемлющей лямбда-выражение области действия. Это называется "захват переменной".
  _Действительно завершённая локальная переменная_ - значение которой не изменяется после её первого присваивания.
  Она не обязательно должна быть объявлена как final.

* Можно создавать ссылки на методы. Ссылка на метод позволяется обращаться к методу, не вызывая его.
  * Ссылки на статические методы: `имя_класса::имя_статического_метода`;
  * Ссылки на методы экземпляра: `ссылка_на_объект::имя_метода`, `имя_класса::имя_метода_экземпляра`, `super::имя_метода_суперкласса`;
  * Ссылки на обобщённые методы;
  * Ссылки на конструкторы: `имя_класса::new`, `имя_класса[]::new` (ссылка на конструктор массива).

## Предопределённые функциональные интерфейсы

Зачастую определять собственный функциональный интерфейс не нужно т.к. JDK 8 добавлен пакет `java.util.function`, 
содержащий предопределённые (встроенные в JDK) обобщённые функциональные интерфейсы.

Некоторые предопределённые функциональные интерфейсы из пакета `java.util.function`:

| Функциональный интерфейс | Назначение                                                                                |
| ------------------------ | ----------------------------------------------------------------------------------------- |
| UnaryOperator<T>         | Выполняет унарную операцию над объектом типа Т и возвращает результат того же типа. Содержит метод apply(). |
| BinaryOperator<T>        | Выполняет логическую операцию над двумя объектами типа Т и возвращает результат того же типа. Содержит метод apply(). |
| Consumer<T>              | Выполняет операцию над объектом типа Т. Содержит метод accept().                          |
| Supplier<T>              | Возвращает объект типа T. Содержит метод get().                                           |
| Function<T, R>           | Выполняет операцию над объектом типа Т и возвращает в результате объект типа R. Содержит метод apply(). |
| Predicate<T>             | Определяет, удовлетворяет ли объект типа T некоторому ограничительному условию. Возвращает логическое значение, обозначающее результат. Содержит метод test(). |
